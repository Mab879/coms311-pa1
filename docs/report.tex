\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Matthew Burket and Joel May}
\title{Programming Assignment 1 Report}
\begin{document}
\maketitle
\section{Hash Table}
\subsection{Pseudo Code} 
\subsubsection{\texttt{add(Tuple t)}}
\begin{verbatim}
add(Tuple t)
   hash = hashFunction.hash(t.key)
    if table[hash] == null
        table[hash] = new LinkedList();
    table[hash].add(t)
    if (loadFactor() > 0.7) 
        newSize = getPrime(size() * 2)
        newTable = LinkedList[newSize]
        newHashFunction = new hashFunction(newSize)
        for list in table
            for tuple in list
                hash =  newHashFunction.hash(t.key)
                newTable[hash].add(t)
\end{verbatim}
\subsubsection{\texttt{search(Tuple t)}}
\begin{verbatim}
search(Tuple t) 
    count = 0;
    hash = hashFunction.hash(t.key)
    for Tuple loopTuple in table[hash]
        if (loopTuple.equals(t))
            count++
    return count
\end{verbatim}
\section{BruteForceSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{vectorLength(strings[])}}
\begin{verbatim}
vectorLength(strings[])
    sum = 0;
    alreadyDone[] = {};
    for each s in strings
        if !alreadyDone.contains(s)
            o = strings.count(s)
            sum += o^2
            alreadyDone += s
    return sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    result[] = {};
    // Create union
    for each s in shinglesS1 + shinglesS2
        if !result.contains(s)
            result.add(s)

    sum = 0
    for each s in result
        sum += shinglesS1.count(s) * shinglesS2.count(s)
    return sum / (lengthOfS1() * lengthOfS2())
\end{verbatim}
\subsection{Data Structures}
The BruteForceSimilarity uses \texttt{ArrayList} as its primary data structure. It doesn't directly use any arrays.
\subsection{Run Time}
\subsubsection{Constructor}
The constructor creates shingles. The \texttt{for} loop executes $n-k$ and $m-k$ times.
The body of the loop uses \texttt{String.substring()}, which is $O(k)$.
The body also adds the new string to an \texttt{ArrayList}, which $O(1)$.
Thus, the run time is $((n-k)+(m-k))*(O(k)+O(1))=(n+m-2k)*O(k)=O(nk+mk+k^2)$.
Since $k$ is bounded to be small ($k<14$ in our implementation), the run time is
effectively $O(n+m)$.
\subsubsection{\texttt{vectorLength()}}
The \texttt{for} loop iterates $n-k$ or $m-k$ (the number of shingles).
In the worst case, the body of the \texttt{if} statement always executes.
The \texttt{strings.count()} method iterates through the list of shingles, $n-k$ or $m-k$.
For each shingle, it does a $O(k)$ comparison. Thus, \texttt{count()} costs
$(n-k)*O(k)$ or $(m-k)*O(k)$. The other two instructions, squaring, adding,
and inserting to an \texttt{ArrayList}, in the \texttt{if} body take $O(1)$.

Overall, $(n-k)*((n-k)*O(k)+O(1))$ or $(m-k)*((m-k)*O(k)+O(1))$. Simplifies to
$O(n-k)*O(nk-k^2)$ or $O(m-k)*O(mk-k^2)$, then $O(n^2k-nk^2+k^3)$ or
$O(m^2k-mk^2+k^3)$.  Since $k$ is bounded to be small ($k<14$ in our
implementation), it may be treated like a constant, which means the run time is
in effect $O(n^2)$ or $O(m^2)$.
\subsubsection{\texttt{similarity()}}
\subsection{Similarity Results}
\section{HashStringSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}} 
\begin{verbatim}
vectorLength(s1MultiSet)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
vectorLength(s2MultiSet)
\end{verbatim}
\subsubsection{\texttt{vectorLength(IterableHashTable s)}}
\begin{verbatim}
vectorLength(IterableHashTable s)
    HashTable countedValues = HashTable(13)
    sum = 0
    for Tuple i in S
        Tuple hashForCompare = t;
        if (countedValues.search(t) == 0)
            countedValues.add(hashForCompare);
            occurrences = S.search(hashForCompare);
            sum += occurrences * occurrences;
    return Math.sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    numerator = 0;
    // unionSet that was created before in the constructor
    for (Tuple i : unionSet)
        numerator += s1MultiSet.search(i) * s2MultiSet.search(i)
    numerator += s1MultiSet.search(hashForCompare) * s2MultiSet.search(hashForCompare);
\end{verbatim}
\subsection{Data Structures }
\subsection{Run Time}
\subsection{Similarity Results}
\section{HashCodeSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\subsubsection{\texttt{lengthOfS2()}}
\subsubsection{\texttt{similarity()}}
\subsection{Data Structure }
\subsection{Run Time}
\section{Similarity Results}
\section{Similarity Equality}
\end{document}