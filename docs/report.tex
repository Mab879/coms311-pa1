\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Matthew Burket and Joel May}
\title{Programming Assignment 1 Report}
\begin{document}
\maketitle
\section{Hash Table}
\subsection{Pseudo Code} 
\subsubsection{\texttt{add(Tuple t)}}
\begin{verbatim}
add(Tuple t)
   hash = hashFunction.hash(t.key)
    if table[hash] == null
        table[hash] = new LinkedList();
    table[hash].add(t)
    if (loadFactor() > 0.7) 
        newSize = getPrime(size() * 2)
        newTable = LinkedList[newSize]
        newHashFunction = new hashFunction(newSize)
        for list in table
            for tuple in list
                hash =  newHashFunction.hash(t.key)
                newTable[hash].add(t)
\end{verbatim}
\subsubsection{\texttt{search(Tuple t)}}
\begin{verbatim}
search(Tuple t) 
    count = 0;
    hash = hashFunction.hash(t.key)
    for Tuple loopTuple in table[hash]
        if (loopTuple.equals(t))
            count++
    return count
\end{verbatim}
\section{BruteForceSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{vectorLength(strings[])}}
\begin{verbatim}
vectorLength(strings[])
    sum = 0;
    alreadyDone[] = {};
    for each s in strings
        if !alreadyDone.contains(s)
            o = strings.count(s)
            sum += o^2
            alreadyDone += s
    return sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    result[] = {};
    // Create union
    for each s in shinglesS1 + shinglesS2
        if !result.contains(s)
            result.add(s)

    sum = 0
    for each s in result
        sum += shinglesS1.count(s) * shinglesS2.count(s)
    return sum / (lengthOfS1() * lengthOfS2())
\end{verbatim}
\subsection{Data Structures}
The BruteForceSimilarity uses \texttt{ArrayList} as its primary data structure. It doesn't directly use any arrays.
\subsection{Run Time}
\subsubsection{Constructor}
The constructor creates shingles. The \texttt{for} loop executes $n-k$ and $m-k$ times.
The body of the loop uses \texttt{String.substring()}, which is $O(k)$.
The body also adds the new string to an \texttt{ArrayList}, which $O(1)$.
Thus, the run time is $((n-k)+(m-k))*(O(k)+O(1))=(n+m-2k)*O(k)=O(nk+mk+k^2)$.
Since $k$ is bounded to be small ($k<14$ in our implementation), the run time is
effectively $O(n+m)$.
\subsubsection{\texttt{vectorLength()}}
The \texttt{for} loop iterates $n-k$ or $m-k$ (the number of shingles).
In the worst case, the body of the \texttt{if} statement always executes.
The \texttt{strings.count()} method iterates through the list of shingles, $n-k$ or $m-k$.
For each shingle, it does a $O(k)$ comparison. Thus, \texttt{count()} costs
$(n-k)*O(k)$ or $(m-k)*O(k)$. The other two instructions, squaring, adding,
and inserting to an \texttt{ArrayList}, in the \texttt{if} body take $O(1)$.

Overall, $(n-k)*((n-k)*O(k)+O(1))$ or $(m-k)*((m-k)*O(k)+O(1))$. Simplifies to
$O(n-k)*O(nk-k^2)$ or $O(m-k)*O(mk-k^2)$, then $O(n^2k-nk^2+k^3)$ or
$O(m^2k-mk^2+k^3)$.  Since $k$ is bounded to be small ($k<14$ in our
implementation), it may be treated like a constant, which means the run time is
in effect $O(n^2)$ or $O(m^2)$.
\subsubsection{\texttt{similarity()}}
The \texttt{for} loop executes $n+m$ times. The \texttt{ArrayList.contains()}
can be assumed to take $O(size)*O(k)$. $O(size)$ is $O(n+m)$ because at worst
$size$ is equal to the number of iterations through the outer \texttt{for} loop.
Adding the item to the \texttt{result} \texttt{ArrayList} is $O(1)$.

At the second \texttt{for} loop, \texttt{size(result)} is at worst $n+m$.
The \texttt{ArrayList.count()}s each take $O(n)*O(k)$ and $O(m)*O(k)$. The
multiplication and adding to \texttt{sum} takes $O(1)$.

The \texttt{lengthOfS1()} and \texttt{lengthOfS2()} have been calculated to be
$O(n^2)$ and $O(m^2)$, respectively. The remaining multiplication and division
is $O(1)$.

Overall, $(n+m)*O(n+m)*(O(k)+O(1))+O(n+m)*(O(n)*O(k)+O(m)*O(k))$. Simplified,
$(n+m)*O(nk+mk)+O(n+m)*O(nk+mk)$. Simplified $O(kn^2+nmk+km^2)+O(kn^2+nmk+km^2)$.
Simplified, $O(kn^2+nmk+km^2)$. Since $k$ is bounded to be small ($k<14$ in
our implementation), it may be treated like a constant. Thus, the run time is
in effect $O(n^2+nm+m^2)$. If $n>m$, $n^2>nm$ and if $n<m$, $m^2>nm$. Thus, we
can simplify further to $O(n^2+m^2)$.
\subsection{Similarity Results}
\section{HashStringSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}} 
\begin{verbatim}
vectorLength(s1MultiSet)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
vectorLength(s2MultiSet)
\end{verbatim}
\subsubsection{\texttt{vectorLength(IterableHashTable s)}}
\begin{verbatim}
vectorLength(IterableHashTable s)
    HashTable countedValues = HashTable(13)
    sum = 0
    for Tuple i in S
        Tuple hashForCompare = t;
        if (countedValues.search(t) == 0)
            countedValues.add(hashForCompare);
            occurrences = S.search(hashForCompare);
            sum += occurrences * occurrences;
    return Math.sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    numerator = 0;
    // unionSet that was created before in the constructor
    for (Tuple i : unionSet)
        numerator += s1MultiSet.search(i) * s2MultiSet.search(i)
    numerator += s1MultiSet.search(hashForCompare) * s2MultiSet.search(hashForCompare);
\end{verbatim}
\subsection{Data Structures}
Hash string uses an iterable hash table. The iterable is an extension of the base hash table that was created for this
assignment. Under the hood the hash table uses an array of LinkedList to store the data. The IterableHashTable stores
a copy of all elements in a List to allow iteration over the elements.
\subsection{Run Time}
\subsubsection{Constructor}
The constructor creates shingles. First the constructor calculates the upper bound by using multiplication, subtractions, and addition. We can use the formula $m + n -2 * k$ or this.
Next the constructor for the HashTable and the HashFunction need to find a prime for the size. Using Bertrand's postulate we know that number. So in the worst case it will take
 $O(2[m + n -2 * k])$ to find the next prime. Next the constructor loads up the hash tables.

Next, we are now in the constructor for the RollingHash. The main thing the constructor does is
calculates the alphaToNMinusOne which takes $O(log(k))$ time.

Next, the step of loading the hashes is working on creating the shingles. The \texttt{for} loop executes $n-k$ or $m-k$ 
times. In the loop the rolling hash is calculated which takes $O(1)$ also takes $O(k)$ to copy the string. Then the 
loop tries to add to the union set. It does this by calling search. Search will find the spot where tuple should be. 
Since we are assume that hash function is perfect it should take $O(k) + O(1)$. Next we, assume that it doesn't exist and 
thus we will need to add with $O(1)$ to  the hash table. Next we will add to the multi-set which will take $O(1)$. 

Overall, $2 * O(m + n - k) + O(1) + [(n-k) + (m-k)] * [O(1) + O(k) + O(1) + O(1) + O(1)]$. 
Simplified, $O(m + n - k) + [O(n-k) + O(m-k)] * O(k)$. 
Simplify, $O(m + n - k) + [O(nk-k^2) + O(km-k^2)])$. We assume that $k$ is bounded is $k < 14$. So it comes a constant.
Thus $O(m + n) + [O(n) + O(m)]$ and simplify $O(m + n)$.
\subsubsection{\texttt{vectorLength()}}
The loop runs for $n-k$ or $m-k$ times. Each iteration of the loop calls \texttt{search(Tuple T)} to check if the given shingle has been done before. As discussed in the constructor section that takes $O(k) + O(1)$. Next, we found the number of times the shingle occurs in $n$ or $m$ using $ \texttt{search(Tuple T)}$  which will take $O(k) + O(1)$. Then the count is square by multiplying by itself which which done in $O(1)$. Then add the squared count to total sum which is $O(1)$. Then after all the iterations take the square root of count. Since we
assume that multiplication takes $O(1)$ we assume that the square root will take $O(1)$. 
\subsection{Similarity Results}
\section{HashCodeSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\begin{verbatim}
vectorLength(s1MultiSet)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
vectorLength(s2MultiSet)
\end{verbatim}
\subsubsection{\texttt{vectorLength(IterableHashTable s)}}
\begin{verbatim}
vectorLength(IterableHashTable s)
    HashTable countedValues = HashTable(13)
    sum = 0
    for Tuple i in S
        Tuple hashForCompare = t;
        if (countedValues.search(t) == 0)
            countedValues.add(hashForCompare);
            occurrences = S.search(hashForCompare);
            sum += occurrences * occurrences;
    return Math.sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    numerator = 0;
    // unionSet that was created before in the constructor
    for (Tuple i : unionSet)
        numerator += s1MultiSet.search(i) * s2MultiSet.search(i)
    numerator += s1MultiSet.search(hashForCompare) * s2MultiSet.search(hashForCompare);
\end{verbatim}
\subsection{Data Structures}
\texttt{HashCodeSimilarity} uses an iterable hash table. The iterable is an extension of the base hash table that was
created for this assignment. Under the hood the hash table uses an array of LinkedList to store the data. The
IterableHashTable stores a copy of all elements in a List to allow iteration over the elements.
\subsection{Run Time}
\section{Similarity Results}
\section{Similarity Equality}
The \texttt{BruteForceSimilarity} and \texttt{HashStringSimilarity} produce the
same results. The former two may output different results from
\texttt{HashCodeSimilarity}. \texttt{BruteForceSimilarity} makes calculations
based on string comparisons alone. \texttt{HashStringSimilarity} compares
strings, but uses hashcodes to locate the strings for comparison. Since the
hashcode function on strings is a total function, all equal strings have the
same hash. This results in fewer string comparisons, but equivalent results. The
\texttt{HashCodeSimilarity} only calculates based on the hashcodes, which allows
for hash collisions to falsely appear as an equivalent string. This affects the
results of the functions in the case of hash collisions.
\end{document}