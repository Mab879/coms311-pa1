\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Matthew Burket and Joel May}
\title{Programming Assignment 1 Report}
\begin{document}
\maketitle
\section{Hash Table}
\subsection{Pseudo Code} 
\subsubsection{\texttt{add(Tuple t)}}
\begin{verbatim}
add(Tuple t)
   hash = hashFunction.hash(t.key)
    if table[hash] == null
        table[hash] = new LinkedList();
    table[hash].add(t)
    if (loadFactor() > 0.7) 
        newSize = getPrime(size() * 2)
        newTable = LinkedList[newSize]
        newHashFunction = new hashFunction(newSize)
        for list in table
            for tuple in list
                hash =  newHashFunction.hash(t.key)
                newTable[hash].add(t)
\end{verbatim}
\subsubsection{\texttt{search(Tuple t)}}
\begin{verbatim}
search(Tuple t) 
    count = 0;
    hash = hashFunction.hash(t.key)
    for Tuple loopTuple in table[hash]
        if (loopTuple.equals(t))
            count++
    return count
\end{verbatim}
\section{BruteForceSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
lengthOfS1()
    return vectorLength(shinglesS1)
\end{verbatim}
\subsubsection{\texttt{vectorLength(strings[])}}
\begin{verbatim}
vectorLength(strings[])
    sum = 0;
    alreadyDone[] = {};
    for each s in strings
        if !alreadyDone.contains(s)
            o = strings.count(s)
            sum += o^2
            alreadyDone += s
    return sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    result[] = {};
    // Create union
    for each s in shinglesS1 + shinglesS2
        if !result.contains(s)
            result.add(s)

    sum = 0
    for each s in result
        sum += shinglesS1.count(s) * shinglesS2.count(s)
    return sum / (lengthOfS1() * lengthOfS2())
\end{verbatim}
\subsection{Data Structures}
The BruteForceSimilarity uses \texttt{ArrayList} as its primary data structure. It doesn't directly use any arrays.
\subsection{Run Time}
\subsubsection{Constructor}
The constructor creates shingles. The \texttt{for} loop executes $n-k$ and $m-k$ times.
The body of the loop uses \texttt{String.substring()}, which is $O(k)$.
The body also adds the new string to an \texttt{ArrayList}, which $O(1)$.
Thus, the run time is $((n-k)+(m-k))*(O(k)+O(1))=(n+m-2k)*O(k)=O(nk+mk+k^2)$.
Since $k$ is bounded to be small ($k<14$ in our implementation), the run time is
effectively $O(n+m)$.
\subsubsection{\texttt{vectorLength()}}
The \texttt{for} loop iterates $n-k$ or $m-k$ (the number of shingles).
In the worst case, the body of the \texttt{if} statement always executes.
The \texttt{strings.count()} method iterates through the list of shingles, $n-k$ or $m-k$.
For each shingle, it does a $O(k)$ comparison. Thus, \texttt{count()} costs
$(n-k)*O(k)$ or $(m-k)*O(k)$. The other two instructions, squaring, adding,
and inserting to an \texttt{ArrayList}, in the \texttt{if} body take $O(1)$.

Overall, $(n-k)*((n-k)*O(k)+O(1))$ or $(m-k)*((m-k)*O(k)+O(1))$. Simplifies to
$O(n-k)*O(nk-k^2)$ or $O(m-k)*O(mk-k^2)$, then $O(n^2k-nk^2+k^3)$ or
$O(m^2k-mk^2+k^3)$.  Since $k$ is bounded to be small ($k<14$ in our
implementation), it may be treated like a constant, which means the run time is
in effect $O(n^2)$ or $O(m^2)$.
\subsubsection{\texttt{similarity()}}
The \texttt{for} loop executes $n+m$ times. The \texttt{ArrayList.contains()}
can be assumed to take $O(size)*O(k)$. $O(size)$ is $O(n+m)$ because at worst
$size$ is equal to the number of iterations through the outer \texttt{for} loop.
Adding the item to the \texttt{result} \texttt{ArrayList} is $O(1)$.

At the second \texttt{for} loop, \texttt{size(result)} is at worst $n+m$.
The \texttt{ArrayList.count()}s each take $O(n)*O(k)$ and $O(m)*O(k)$. The
multiplication and adding to \texttt{sum} takes $O(1)$.

The \texttt{lengthOfS1()} and \texttt{lengthOfS2()} have been calculated to be
$O(n^2)$ and $O(m^2)$, respectively. The remaining multiplication and division
is $O(1)$.

Overall, $(n+m)*O(n+m)*(O(k)+O(1))+O(n+m)*(O(n)*O(k)+O(m)*O(k))$. Simplified,
$(n+m)*O(nk+mk)+O(n+m)*O(nk+mk)$. Simplified $O(kn^2+nmk+km^2)+O(kn^2+nmk+km^2)$.
Simplified, $O(kn^2+nmk+km^2)$. Since $k$ is bounded to be small ($k<14$ in
our implementation), it may be treated like a constant. Thus, the run time is
in effect $O(n^2+nm+m^2)$. If $n>m$, $n^2>nm$ and if $n<m$, $m^2>nm$. Thus, we
can simplify further to $O(n^2+m^2)$.
\subsection{Similarity Results}
\section{HashStringSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}} 
\begin{verbatim}
vectorLength(s1MultiSet)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
vectorLength(s2MultiSet)
\end{verbatim}
\subsubsection{\texttt{vectorLength(IterableHashTable s)}}
\begin{verbatim}
vectorLength(IterableHashTable s)
    HashTable countedValues = HashTable(13)
    sum = 0
    for Tuple i in S
        Tuple hashForCompare = t;
        if (countedValues.search(t) == 0)
            countedValues.add(hashForCompare);
            occurrences = S.search(hashForCompare);
            sum += occurrences * occurrences;
    return Math.sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    numerator = 0;
    // unionSet that was created before in the constructor
    for (Tuple i : unionSet)
        numerator += s1MultiSet.search(i) * s2MultiSet.search(i)
    numerator += s1MultiSet.search(hashForCompare) * s2MultiSet.search(hashForCompare);
\end{verbatim}
\subsection{Data Structures}
Hash string uses an iterable hash table. The iterable is an extension of the base hash table that was created for this 
assignment. Under the hood the hash table uses an array of LinkedList to store the data. The IterableHashTable has 
iterator to work over the all entries in the hash table.
\subsection{Run Time}
\subsubsection{Constructor}
The constructor is what creates the shingles and loads up the hash table. The rolling hash calculates the exponent once
and the running time is assumed to be $O(k)$. Next the rolling hash loops over the string. This loop will run 
$n-k$ or $m-k$ times. On each iteration of the loop the rolling hash takes $O(k)$. Then the loop adds the item to the union set. It does 
by calling HashTable.search(Tuple t) which walks though the tuples in the in that list. The worst case would be that 
will strings ended up in the same row so the worst-case running time would be $O(k)$. If the doesn't find it then it 
would add it to the union set which would be $O(1)$. Then last action of the is to add to the sMultiSet which is time 
to find the hash of key and and place in the correct link list which can be effectively called $O(1)$.

Overall, the running time is $(n-k) + (m-k) * (O(k)+O(k)+O(n)+O(1)+O(1))$. We can simplify to $(m-k) + (n-k) * O(1)$. 
Also since we know that $k < 14$ in our implementation we can say if is effectively $O(m+n)$.   
\subsubsection{\texttt{vectorLength()}}
The loop runs for $n-k$ or $m-k$ times.
\subsection{Similarity Results}
\section{HashCodeSimilarity}
\subsection{Pseudo Code}
\subsubsection{\texttt{lengthOfS1()}}
\begin{verbatim}
vectorLength(s1MultiSet)
\end{verbatim}
\subsubsection{\texttt{lengthOfS2()}}
\begin{verbatim}
vectorLength(s2MultiSet)
\end{verbatim}
\subsubsection{\texttt{vectorLength(IterableHashTable s)}}
\begin{verbatim}
vectorLength(IterableHashTable s)
    HashTable countedValues = HashTable(13)
    sum = 0
    for Tuple i in S
        Tuple hashForCompare = t;
        if (countedValues.search(t) == 0)
            countedValues.add(hashForCompare);
            occurrences = S.search(hashForCompare);
            sum += occurrences * occurrences;
    return Math.sqrt(sum)
\end{verbatim}
\subsubsection{\texttt{similarity()}}
\begin{verbatim}
similarity()
    numerator = 0;
    // unionSet that was created before in the constructor
    for (Tuple i : unionSet)
        numerator += s1MultiSet.search(i) * s2MultiSet.search(i)
    numerator += s1MultiSet.search(hashForCompare) * s2MultiSet.search(hashForCompare);
\end{verbatim}
\subsection{Data Structure }
\subsection{Run Time}
\section{Similarity Results}
\section{Similarity Equality}
The \texttt{BruteForceSimilarity} and \texttt{HashStringSimilarity} produce the
same results. The former two may output different results from
\texttt{HashCodeSimilarity}. \texttt{BruteForceSimilarity} makes calculations
based on string comparisons alone. \texttt{HashStringSimilarity} compares
strings, but uses hashcodes to locate the strings for comparison. Since the
hashcode function on strings is a total function, all equal strings have the
same hash. This results in fewer string comparisons, but equivalent results. The
\texttt{HashCodeSimilarity} only calculates based on the hashcodes, which allows
for hash collisions to falsely appear as an equivalent string. This affects the
results of the functions in the case of hash collisions.
\end{document}